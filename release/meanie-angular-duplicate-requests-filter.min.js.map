{"version":3,"sources":["meanie-angular-duplicate-requests-filter.min.js","duplicate-requests-filter.js"],"names":["_typeof","Symbol","iterator","obj","constructor","window","angular","undefined","module","config","$provide","decorator","$delegate","$q","hash","str","h","strlen","length","n","i","charCodeAt","getRequestIdentifier","method","url","data","toJson","$duplicateRequestsFilter","ignoreDuplicateRequest","$http","identifier","pendingRequests","rejectDuplicateRequest","reject","headers","status","rejectDuplicateStatusCode","Object","keys","filter","key","forEach"],"mappings":"AAMA,YAEA,IAAIA,SAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,OAAS,eAAkBE,KAE1O,SAAWE,EAAQC,EAASC,GAO1BD,EAAQE,OAAO,wCAKdC,QAAQ,WAAY,SAAUC,GAK7BA,EAASC,UAAU,SAAU,YAAa,KAAM,SAAUC,EAAWC,GASnE,QCNKC,GAAIC,GDOP,GCNAC,GAAI,EACJC,EAAWF,EAAKG,MDOhB,ICNQ,IAARD,EDOE,MAAOD,EAET,KAAK,GAAWG,GAAPC,EAAI,EAAMA,EAAIH,IAAUG,EAC/BD,EAAIJ,EAAIM,WAAWD,GACnBJ,GAAKA,GAAK,GAAKA,EAAIG,EACnBH,GAAQA,CCJd,OAASA,KAAA,EDYP,QAASM,GAAqBb,GAC5B,GAAIM,GAAMN,EAAOc,OAASd,EAAOe,GCFrC,ODGQf,GAAOgB,MAAiC,WAAzBzB,QAAQS,EAAOgB,QAChCV,GAAOT,EAAQoB,OAAOjB,EAAOgB,OCJ1BX,EAAAC,GDYP,QAASY,GAAyBlB,GAGhC,GAAIA,EAAOmB,uBACT,MAAOC,GAAMpB,EAIf,IAAIqB,GCNMR,EAAAb,EDSV,OAAIsB,GCNQD,GDONrB,EAAOuB,uBACFnB,EAAGoB,QCLdR,KAAO,GDODS,WACAC,OAAQ1B,EAAO2B,2BAA6B,IAC5C3B,OAAQA,IAGLsB,EAAgBD,IAIzBC,EAAgBD,GAAcD,EAAMpB,GAANoB,WAAsB,iBAC3CE,GAAgBD,KCF1BC,EAAQD,IA/DX,GAAAC,MACEF,EAAQjB,CD+ER,OAPAyB,QAAOC,KAAKT,GAAOU,OAAO,SAAUC,GCPtC,MAAO,kBAAAX,GAAAW,KDSFC,QAAQ,SAAUD,GACnB,MAAOb,GAAyBa,GAAOX,EAAMW,KAIxCb,SAGVtB,OAAQA,OAAOC","file":"meanie-angular-duplicate-requests-filter.min.js","sourcesContent":["/**\n * meanie-angular-duplicate-requests-filter * https://github.com/meanie/angular-duplicate-requests-filter\n *\n * Copyright (c) 2016 Adam Buczynski <me@adambuczynski.com>\n * License: MIT\n */\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n(function (window, angular, undefined) {\n  'use strict';\n\n  /**\n   * Module definition and dependencies\n   */\n\n  angular.module('DuplicateRequestsFilter.Decorator', [])\n\n  /**\n   * Config\n   */\n  .config(['$provide', function ($provide) {\n\n    /**\n     * Decorator for the $http service\n     */\n    $provide.decorator('$http', ['$delegate', '$q', function ($delegate, $q) {\n\n      //Pending requests and local $http let for natural reference\n      var pendingRequests = {};\n      var $http = $delegate;\n\n      /**\n       * Hash generator\n       */\n      function hash(str) {\n        var h = 0;\n        var strlen = str.length;\n        if (strlen === 0) {\n          return h;\n        }\n        for (var i = 0, n; i < strlen; ++i) {\n          n = str.charCodeAt(i);\n          h = (h << 5) - h + n;\n          h = h & h;\n        }\n        return h >>> 0;\n      }\n\n      /**\n       * Helper to generate a unique identifier for a request\n       */\n      function getRequestIdentifier(config) {\n        var str = config.method + config.url;\n        if (config.data && _typeof(config.data) === 'object') {\n          str += angular.toJson(config.data);\n        }\n        return hash(str);\n      }\n\n      /**\n       * Modified $http service\n       */\n      function $duplicateRequestsFilter(config) {\n\n        //Ignore for this request?\n        if (config.ignoreDuplicateRequest) {\n          return $http(config);\n        }\n\n        //Get unique request identifier\n        var identifier = getRequestIdentifier(config);\n\n        //Check if such a request is pending already\n        if (pendingRequests[identifier]) {\n          if (config.rejectDuplicateRequest) {\n            return $q.reject({\n              data: '',\n              headers: {},\n              status: config.rejectDuplicateStatusCode || 400,\n              config: config\n            });\n          }\n          return pendingRequests[identifier];\n        }\n\n        //Create promise using $http and make sure it's reset when resolved\n        pendingRequests[identifier] = $http(config).finally(function () {\n          delete pendingRequests[identifier];\n        });\n\n        //Return promise\n        return pendingRequests[identifier];\n      }\n\n      //Map rest of methods\n      Object.keys($http).filter(function (key) {\n        return typeof $http[key] === 'function';\n      }).forEach(function (key) {\n        return $duplicateRequestsFilter[key] = $http[key];\n      });\n\n      //Return it\n      return $duplicateRequestsFilter;\n    }]);\n  }]);\n})(window, window.angular);","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('DuplicateRequestsFilter.Decorator', [])\n\n/**\n * Config\n */\n.config(function($provide) {\n\n  /**\n   * Decorator for the $http service\n   */\n  $provide.decorator('$http', function($delegate, $q) {\n\n    //Pending requests and local $http let for natural reference\n    let pendingRequests = {};\n    let $http = $delegate;\n\n    /**\n     * Hash generator\n     */\n    function hash(str) {\n      let h = 0;\n      let strlen = str.length;\n      if (strlen === 0) {\n        return h;\n      }\n      for (let i = 0, n; i < strlen; ++i) {\n        n = str.charCodeAt(i);\n        h = ((h << 5) - h) + n;\n        h = h & h;\n      }\n      return h >>> 0;\n    }\n\n    /**\n     * Helper to generate a unique identifier for a request\n     */\n    function getRequestIdentifier(config) {\n      let str = config.method + config.url;\n      if (config.data && typeof config.data === 'object') {\n        str += angular.toJson(config.data);\n      }\n      return hash(str);\n    }\n\n    /**\n     * Modified $http service\n     */\n    function $duplicateRequestsFilter(config) {\n\n      //Ignore for this request?\n      if (config.ignoreDuplicateRequest) {\n        return $http(config);\n      }\n\n      //Get unique request identifier\n      let identifier = getRequestIdentifier(config);\n\n      //Check if such a request is pending already\n      if (pendingRequests[identifier]) {\n        if (config.rejectDuplicateRequest) {\n          return $q.reject({\n            data: '',\n            headers: {},\n            status: config.rejectDuplicateStatusCode || 400,\n            config: config\n          });\n        }\n        return pendingRequests[identifier];\n      }\n\n      //Create promise using $http and make sure it's reset when resolved\n      pendingRequests[identifier] = $http(config).finally(() => {\n        delete pendingRequests[identifier];\n      });\n\n      //Return promise\n      return pendingRequests[identifier];\n    }\n\n    //Map rest of methods\n    Object.keys($http)\n      .filter(key => (typeof $http[key] === 'function'))\n      .forEach(key => $duplicateRequestsFilter[key] = $http[key]);\n\n    //Return it\n    return $duplicateRequestsFilter;\n  });\n});\n\n})(window, window.angular);\n"],"sourceRoot":"/source/"}