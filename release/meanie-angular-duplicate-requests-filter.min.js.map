{"version":3,"sources":["meanie-angular-duplicate-requests-filter.min.js","duplicate-requests-filter.js"],"names":["_typeof","Symbol","iterator","obj","constructor","window","angular","undefined","module","config","$provide","decorator","$delegate","$q","hash","str","h","strlen","length","n","i","charCodeAt","getRequestIdentifier","method","url","params","toJson","data","$duplicateRequestsFilter","ignoreDuplicateRequest","$http","identifier","pendingRequests","rejectDuplicateRequest","reject","headers","status","rejectDuplicateStatusCode","Object","keys","filter","key","forEach"],"mappings":"AAMA,GAAIA,SAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,OAAS,eAAkBE,KAE1O,SAAWE,EAAQC,EAASC,GCH5B,YDUED,GAAQE,OAAO,wCAKdC,QAAQ,WAAY,SAAUC,GAK7BA,EAASC,UAAU,SAAU,YAAa,KAAM,SAAUC,EAAWC,GASnE,QCJKC,GAAIC,GDKP,GCJAC,GAAI,EACJC,EAAWF,EAAKG,MDKhB,ICJQ,IAARD,EDKE,MAAOD,EAET,KAAK,GAAWG,GAAPC,EAAI,EAAMA,EAAIH,IAAUG,EAC/BD,EAAIJ,EAAIM,WAAWD,GACnBJ,GAAKA,GAAK,GAAKA,EAAIG,EACnBH,GAAQA,CCFd,OAASA,KAAA,EDUP,QCJEM,GAAsBb,GDKtB,GAAIM,GAAMN,EAAOc,OAASd,EAAOe,GCGrC,OANEf,GAAOgB,QAAK,WAAAzB,QAAAS,EAAAgB,UDKRV,GAAOT,EAAQoB,OAAOjB,EAAOgB,SAE3BhB,EAAOkB,MAAiC,WAAzB3B,QAAQS,EAAOkB,QAChCZ,GAAOT,EAAQoB,OAAOjB,EAAOkB,OCF1Bb,EAAAC,GDUP,QAASa,GAAyBnB,GAGhC,GAAIA,EAAOoB,uBACT,MAAOC,GAAMrB,EAIf,IAAIsB,GCJMT,EAAAb,EDOV,OAAIuB,GCJQD,GDKNtB,EAAOwB,uBACFpB,EAAGqB,QCHdP,KAAO,GDKDQ,WACAC,OAAQ3B,EAAO4B,2BAA6B,IAC5C5B,OAAQA,IAGLuB,EAAgBD,IAIzBC,EAAgBD,GAAcD,EAAMrB,GAANqB,WAAsB,iBAC3CE,GAAgBD,KCA1BC,EAAQD,IAlEX,GAAAC,MACEF,EAAQlB,CDgFR,OAPA0B,QAAOC,KAAKT,GAAOU,OAAO,SAAUC,GCLtC,MAAO,kBAAAX,GAAAW,KDOFC,QAAQ,SAAUD,GACnB,MAAOb,GAAyBa,GAAOX,EAAMW,KAIxCb,SAGVvB,OAAQA,OAAOC","file":"meanie-angular-duplicate-requests-filter.min.js","sourcesContent":["/**\n * meanie-angular-duplicate-requests-filter * https://github.com/meanie/angular-duplicate-requests-filter\n *\n * Copyright (c) 2016 Adam Reis <adam@reis.nz>\n * License: MIT\n */\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n(function (window, angular, undefined) {\n  'use strict';\n\n  /**\n   * Module definition and dependencies\n   */\n\n  angular.module('DuplicateRequestsFilter.Decorator', [])\n\n  /**\n   * Config\n   */\n  .config(['$provide', function ($provide) {\n\n    /**\n     * Decorator for the $http service\n     */\n    $provide.decorator('$http', ['$delegate', '$q', function ($delegate, $q) {\n\n      //Pending requests and local $http let for natural reference\n      var pendingRequests = {};\n      var $http = $delegate;\n\n      /**\n       * Hash generator\n       */\n      function hash(str) {\n        var h = 0;\n        var strlen = str.length;\n        if (strlen === 0) {\n          return h;\n        }\n        for (var i = 0, n; i < strlen; ++i) {\n          n = str.charCodeAt(i);\n          h = (h << 5) - h + n;\n          h = h & h;\n        }\n        return h >>> 0;\n      }\n\n      /**\n       * Helper to generate a unique identifier for a request\n       */\n      function getRequestIdentifier(config) {\n        var str = config.method + config.url;\n        if (config.params && _typeof(config.params) === 'object') {\n          str += angular.toJson(config.params);\n        }\n        if (config.data && _typeof(config.data) === 'object') {\n          str += angular.toJson(config.data);\n        }\n        return hash(str);\n      }\n\n      /**\n       * Modified $http service\n       */\n      function $duplicateRequestsFilter(config) {\n\n        //Ignore for this request?\n        if (config.ignoreDuplicateRequest) {\n          return $http(config);\n        }\n\n        //Get unique request identifier\n        var identifier = getRequestIdentifier(config);\n\n        //Check if such a request is pending already\n        if (pendingRequests[identifier]) {\n          if (config.rejectDuplicateRequest) {\n            return $q.reject({\n              data: '',\n              headers: {},\n              status: config.rejectDuplicateStatusCode || 400,\n              config: config\n            });\n          }\n          return pendingRequests[identifier];\n        }\n\n        //Create promise using $http and make sure it's reset when resolved\n        pendingRequests[identifier] = $http(config).finally(function () {\n          delete pendingRequests[identifier];\n        });\n\n        //Return promise\n        return pendingRequests[identifier];\n      }\n\n      //Map rest of methods\n      Object.keys($http).filter(function (key) {\n        return typeof $http[key] === 'function';\n      }).forEach(function (key) {\n        return $duplicateRequestsFilter[key] = $http[key];\n      });\n\n      //Return it\n      return $duplicateRequestsFilter;\n    }]);\n  }]);\n})(window, window.angular);","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('DuplicateRequestsFilter.Decorator', [])\n\n/**\n * Config\n */\n.config(function($provide) {\n\n  /**\n   * Decorator for the $http service\n   */\n  $provide.decorator('$http', function($delegate, $q) {\n\n    //Pending requests and local $http let for natural reference\n    let pendingRequests = {};\n    let $http = $delegate;\n\n    /**\n     * Hash generator\n     */\n    function hash(str) {\n      let h = 0;\n      let strlen = str.length;\n      if (strlen === 0) {\n        return h;\n      }\n      for (let i = 0, n; i < strlen; ++i) {\n        n = str.charCodeAt(i);\n        h = ((h << 5) - h) + n;\n        h = h & h;\n      }\n      return h >>> 0;\n    }\n\n    /**\n     * Helper to generate a unique identifier for a request\n     */\n    function getRequestIdentifier(config) {\n      let str = config.method + config.url;\n      if (config.params && typeof config.params === 'object') {\n        str += angular.toJson(config.params);\n      }\n      if (config.data && typeof config.data === 'object') {\n        str += angular.toJson(config.data);\n      }\n      return hash(str);\n    }\n\n    /**\n     * Modified $http service\n     */\n    function $duplicateRequestsFilter(config) {\n\n      //Ignore for this request?\n      if (config.ignoreDuplicateRequest) {\n        return $http(config);\n      }\n\n      //Get unique request identifier\n      let identifier = getRequestIdentifier(config);\n\n      //Check if such a request is pending already\n      if (pendingRequests[identifier]) {\n        if (config.rejectDuplicateRequest) {\n          return $q.reject({\n            data: '',\n            headers: {},\n            status: config.rejectDuplicateStatusCode || 400,\n            config: config,\n          });\n        }\n        return pendingRequests[identifier];\n      }\n\n      //Create promise using $http and make sure it's reset when resolved\n      pendingRequests[identifier] = $http(config).finally(() => {\n        delete pendingRequests[identifier];\n      });\n\n      //Return promise\n      return pendingRequests[identifier];\n    }\n\n    //Map rest of methods\n    Object.keys($http)\n      .filter(key => (typeof $http[key] === 'function'))\n      .forEach(key => $duplicateRequestsFilter[key] = $http[key]);\n\n    //Return it\n    return $duplicateRequestsFilter;\n  });\n});\n\n})(window, window.angular);\n"],"sourceRoot":"/source/"}