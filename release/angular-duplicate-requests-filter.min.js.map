{"version":3,"sources":["angular-duplicate-requests-filter.min.js","duplicate-requests-filter.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","window","angular","undefined","module","config","$provide","decorator","$delegate","$q","hash","i","n","str","h","strlen","charCodeAt","getRequestIdentifier","method","url","toJson","params","data","$duplicateRequestsFilter","ignoreDuplicateRequest","$http","identifier","pendingRequests","rejectDuplicateRequest","reject","headers","status","rejectDuplicateStatusCode","forEach","Object","keys","filter","key","defaults"],"mappings":"AAMA,GAAIA,SAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,QAAUE,IAAQF,OAAOI,UAAY,eAAkBF,KAEtQ,SAAWG,EAAQC,EAASC,GCH5BD,YDUEA,GAAQE,OAAO,wCAKdC,QAAQ,WAAY,SAAUC,GAK7BA,EAASC,UAAU,SAAU,YAAa,KAAM,SAAUC,EAAWC,GASnE,QCJKC,GAAIC,GDKP,GCJAC,GAAIC,EACJC,EAAWD,EAAKC,MDKhB,ICJQA,IAARA,EDKE,MAAOA,EAET,KAAK,GAAWF,GAAPD,EAAI,EAAMA,EAAII,IAAUJ,EAC/BC,EAAIC,EAAIG,WAAWL,GACnBG,GAAKA,GAAK,GAAKA,EAAIF,EACnBE,GAAQA,CCFd,OAASG,KAAAA,EDUP,QCJEJ,GAAsBR,GDKtB,GAAIQ,GAAMR,EAAOa,OAASb,EAAOc,GCGrC,OANEd,GAAOK,QAAKG,WAAAA,QAAAA,EAAAA,UDKRA,GAAOX,EAAQkB,OAAOf,EAAOgB,SAE3BhB,EAAOiB,MAAiC,WAAzB3B,QAAQU,EAAOiB,QAChCT,GAAOX,EAAQkB,OAAOf,EAAOiB,OCF1BC,EAAAA,GDUP,QAASA,GAAyBlB,GAGhC,GAAIA,EAAOmB,uBACT,MAAOC,GAAMpB,EAIf,IAAIqB,GCJMT,EAAAZ,EDOV,OAAIsB,GCJQtB,GDKNA,EAAOuB,uBACFnB,EAAGoB,QCHdP,KAAOK,GDKDG,WACAC,OAAQ1B,EAAO2B,2BAA6B,IAC5C3B,OAAQA,IAGLsB,EAAgBD,IAIzBC,EAAgBD,GAAcD,EAAMpB,GAANoB,WAAsB,iBAC3CE,GAAgBD,KCC1BO,EAAQP,IAnEX,GAAAC,MACEF,EAAQjB,CDmFR,OAVA0B,QAAOC,KAAKV,GAAOW,OAAO,SAAUC,GCJtCd,MAAyBe,kBAAzBf,GAAAA,KDMKU,QAAQ,SAAUI,GACnB,MAAOd,GAAyBc,GAAOZ,EAAMY,KCAlDpC,EArGHqC,SAAAb,EAAAa,SD4Gaf,SAGVtB,OAAQA,OAAOC","file":"angular-duplicate-requests-filter.min.js","sourcesContent":["/**\n * @meanie/angular-duplicate-requests-filter * https://github.com/meanie/angular-duplicate-requests-filter\n *\n * Copyright (c) 2018 Adam Reis <adam@reis.nz>\n * License: MIT\n */\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function (window, angular, undefined) {\n  'use strict';\n\n  /**\n   * Module definition and dependencies\n   */\n\n  angular.module('DuplicateRequestsFilter.Decorator', [])\n\n  /**\n   * Config\n   */\n  .config(['$provide', function ($provide) {\n\n    /**\n     * Decorator for the $http service\n     */\n    $provide.decorator('$http', ['$delegate', '$q', function ($delegate, $q) {\n\n      //Pending requests and local $http let for natural reference\n      var pendingRequests = {};\n      var $http = $delegate;\n\n      /**\n       * Hash generator\n       */\n      function hash(str) {\n        var h = 0;\n        var strlen = str.length;\n        if (strlen === 0) {\n          return h;\n        }\n        for (var i = 0, n; i < strlen; ++i) {\n          n = str.charCodeAt(i);\n          h = (h << 5) - h + n;\n          h = h & h;\n        }\n        return h >>> 0;\n      }\n\n      /**\n       * Helper to generate a unique identifier for a request\n       */\n      function getRequestIdentifier(config) {\n        var str = config.method + config.url;\n        if (config.params && _typeof(config.params) === 'object') {\n          str += angular.toJson(config.params);\n        }\n        if (config.data && _typeof(config.data) === 'object') {\n          str += angular.toJson(config.data);\n        }\n        return hash(str);\n      }\n\n      /**\n       * Modified $http service\n       */\n      function $duplicateRequestsFilter(config) {\n\n        //Ignore for this request?\n        if (config.ignoreDuplicateRequest) {\n          return $http(config);\n        }\n\n        //Get unique request identifier\n        var identifier = getRequestIdentifier(config);\n\n        //Check if such a request is pending already\n        if (pendingRequests[identifier]) {\n          if (config.rejectDuplicateRequest) {\n            return $q.reject({\n              data: '',\n              headers: {},\n              status: config.rejectDuplicateStatusCode || 400,\n              config: config\n            });\n          }\n          return pendingRequests[identifier];\n        }\n\n        //Create promise using $http and make sure it's reset when resolved\n        pendingRequests[identifier] = $http(config).finally(function () {\n          delete pendingRequests[identifier];\n        });\n\n        //Return promise\n        return pendingRequests[identifier];\n      }\n\n      //Map rest of methods\n      Object.keys($http).filter(function (key) {\n        return typeof $http[key] === 'function';\n      }).forEach(function (key) {\n        return $duplicateRequestsFilter[key] = $http[key];\n      });\n\n      //Map defaults\n      $duplicateRequestsFilter.defaults = $http.defaults;\n\n      //Return it\n      return $duplicateRequestsFilter;\n    }]);\n  }]);\n})(window, window.angular);","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('DuplicateRequestsFilter.Decorator', [])\n\n/**\n * Config\n */\n.config(function($provide) {\n\n  /**\n   * Decorator for the $http service\n   */\n  $provide.decorator('$http', function($delegate, $q) {\n\n    //Pending requests and local $http let for natural reference\n    let pendingRequests = {};\n    let $http = $delegate;\n\n    /**\n     * Hash generator\n     */\n    function hash(str) {\n      let h = 0;\n      let strlen = str.length;\n      if (strlen === 0) {\n        return h;\n      }\n      for (let i = 0, n; i < strlen; ++i) {\n        n = str.charCodeAt(i);\n        h = ((h << 5) - h) + n;\n        h = h & h;\n      }\n      return h >>> 0;\n    }\n\n    /**\n     * Helper to generate a unique identifier for a request\n     */\n    function getRequestIdentifier(config) {\n      let str = config.method + config.url;\n      if (config.params && typeof config.params === 'object') {\n        str += angular.toJson(config.params);\n      }\n      if (config.data && typeof config.data === 'object') {\n        str += angular.toJson(config.data);\n      }\n      return hash(str);\n    }\n\n    /**\n     * Modified $http service\n     */\n    function $duplicateRequestsFilter(config) {\n\n      //Ignore for this request?\n      if (config.ignoreDuplicateRequest) {\n        return $http(config);\n      }\n\n      //Get unique request identifier\n      let identifier = getRequestIdentifier(config);\n\n      //Check if such a request is pending already\n      if (pendingRequests[identifier]) {\n        if (config.rejectDuplicateRequest) {\n          return $q.reject({\n            data: '',\n            headers: {},\n            status: config.rejectDuplicateStatusCode || 400,\n            config: config,\n          });\n        }\n        return pendingRequests[identifier];\n      }\n\n      //Create promise using $http and make sure it's reset when resolved\n      pendingRequests[identifier] = $http(config).finally(() => {\n        delete pendingRequests[identifier];\n      });\n\n      //Return promise\n      return pendingRequests[identifier];\n    }\n\n    //Map rest of methods\n    Object\n      .keys($http)\n      .filter(key => (typeof $http[key] === 'function'))\n      .forEach(key => $duplicateRequestsFilter[key] = $http[key]);\n\n    //Map defaults\n    $duplicateRequestsFilter.defaults = $http.defaults;\n\n    //Return it\n    return $duplicateRequestsFilter;\n  });\n});\n\n})(window, window.angular);\n"]}